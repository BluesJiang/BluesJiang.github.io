<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="源码阅读," />










<meta name="description" content="CyidaSubstrate 的核心功能就是提供了一个强大的注入功能  Cydia Substrate - Powerful Code Insertion Platform –  Cydia Substrate 源代码注释   其中提供了两个核心的 Hook 函数  MSHookMessageEx – 用于 hook Objective-C 方法 MSHookFunction – 用于 hook">
<meta name="keywords" content="源码阅读">
<meta property="og:type" content="article">
<meta property="og:title" content="Cydia 的 Hook 原理">
<meta property="og:url" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/index.html">
<meta property="og:site_name" content="BluesJiang">
<meta property="og:description" content="CyidaSubstrate 的核心功能就是提供了一个强大的注入功能  Cydia Substrate - Powerful Code Insertion Platform –  Cydia Substrate 源代码注释   其中提供了两个核心的 Hook 函数  MSHookMessageEx – 用于 hook Objective-C 方法 MSHookFunction – 用于 hook">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441006537689.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441020057624.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441547925906.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441532148701.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441020057624.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441547925906.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441661281597.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441669629199.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441679053396.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441760691225.jpg">
<meta property="og:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441763854689.jpg">
<meta property="og:updated_time" content="2018-12-07T12:36:08.240Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cydia 的 Hook 原理">
<meta name="twitter:description" content="CyidaSubstrate 的核心功能就是提供了一个强大的注入功能  Cydia Substrate - Powerful Code Insertion Platform –  Cydia Substrate 源代码注释   其中提供了两个核心的 Hook 函数  MSHookMessageEx – 用于 hook Objective-C 方法 MSHookFunction – 用于 hook">
<meta name="twitter:image" content="https://bluesjiang.coding.me/Cydia-的-Hook-原理/15441006537689.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://bluesjiang.coding.me/Cydia-的-Hook-原理/"/>





<meta name="baidu-site-verification" content="84JyTny968" />


  <title>Cydia 的 Hook 原理 | BluesJiang</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0a6938376c62cf496032c7169aa31e64";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BluesJiang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://bluesjiang.coding.me/Cydia-的-Hook-原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BluesJiang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BluesJiang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Cydia 的 Hook 原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-07T18:14:11+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS逆向/" itemprop="url" rel="index">
                    <span itemprop="name">iOS逆向</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>CyidaSubstrate 的核心功能就是提供了一个强大的注入功能</p>
<blockquote>
<p>Cydia Substrate - Powerful Code Insertion Platform<br>
– <cite> Cydia Substrate 源代码注释 </cite></p>
</blockquote>
<p>其中提供了两个核心的 Hook 函数</p>
<ul>
<li><code>MSHookMessageEx</code> – 用于 hook Objective-C 方法</li>
<li><code>MSHookFunction</code> – 用于 hook C 语言函数</li>
</ul>
<p>但是还有一个上次提到的 <code>MSHookProcess</code>，但是这个并不是属于公开的部分，但是也是做了 hook 工作。</p>
<h2 id="mshookprocess"><a class="markdownIt-Anchor" href="#mshookprocess"></a> MSHookProcess</h2>
<p>这个是在上一篇说明启动原理时提到的一个注入 Cyida 就是利用了这个函数在系统启动时对 launchd 进行了注入。<br>
这里先简单说一下结论：</p>
<blockquote>
<p>函数利用了一些 mach 调用，在宿主进程的空间中分配了一些内存，然后将蹦床注入。<br>
然后开启一个新的线程，执行蹦床的相应函数，引导目标动态库的加载，完成注入。</p>
</blockquote>
<a id="more"></a>
<h3 id="注入蹦床"><a class="markdownIt-Anchor" href="#注入蹦床"></a> 注入蹦床</h3>
<p>注入蹦床的核心函数就在 <code>MSHookProcess</code> 中，函数原型为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_<span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">MSHookProcess</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">const</span> <span class="keyword">char</span> *library)</span></span></div></pre></td></tr></table></figure>
<p>函数首先通过下面的代码分配了一些栈空间以及和一个 <code>Baton</code> 数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (library[<span class="number">0</span>] != <span class="string">'/'</span>) &#123;</div><div class="line">    MSLog(MSLogLevelError, <span class="string">"MSError: require absolute path to %s"</span>, library);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里在栈上分配内存，保证有足够的空间来容放系带结构体以及运行空间</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> size_t <span class="title">Stack_</span><span class="params">(<span class="number">8</span> * <span class="number">1024</span>)</span></span>;</div><div class="line"><span class="keyword">size_t</span> length(<span class="built_in">strlen</span>(library) + <span class="number">1</span>), depth(<span class="keyword">sizeof</span>(Baton) + length);</div><div class="line">depth = (depth + <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>) + <span class="number">1</span>) / <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</div><div class="line"></div><div class="line"><span class="keyword">uint8_t</span> local[depth];</div><div class="line">Baton *baton(reinterpret_cast&lt;Baton *&gt;(local));</div><div class="line"></div><div class="line"><span class="comment">// the dyld shared cache is only shuffled once per boot, allowing us to assume no ASLR</span></div><div class="line"><span class="comment">// however, it is important that we restrict ourselves to those in cached libraries</span></div><div class="line"><span class="comment">// <span class="doctag">XXX:</span> it would be preferable to do this in a cross-architecture way, remotely</span></div><div class="line"><span class="comment">// 这里捕捉了一些关键的函数，因为这些函数在蹦床的执行中需要用到</span></div><div class="line"><span class="comment">// 但是蹦床编写不能直接在代码中引用这些函数，所以通过系带 Baton 记录下来</span></div><div class="line"><span class="comment">// 这些函数地址一般在共享缓存在启动加载时就固定了，在其它进程中也能正确访问</span></div><div class="line"><span class="comment">// 由下面的可以看出 Baton 的结构</span></div><div class="line">baton-&gt;__pthread_set_self = &amp;__pthread_set_self;</div><div class="line">baton-&gt;pthread_create = &amp;pthread_create;</div><div class="line">baton-&gt;pthread_join = &amp;pthread_join;</div><div class="line">baton-&gt;mach_thread_self = &amp;mach_thread_self;</div><div class="line">baton-&gt;thread_terminate = &amp;thread_terminate;</div><div class="line">baton-&gt;dlerror = &amp;dlerror;</div><div class="line">baton-&gt;dlsym = &amp;dlsym;</div><div class="line"><span class="built_in">memcpy</span>(baton-&gt;library, library, length);</div></pre></td></tr></table></figure>
<p>接下来就是让 Baton 结构进入到宿主进程的空间中。这里是通过 mach 的系统调用完成，因为已经越狱，我们的程序是拥有 root 权限的，所以可以给其他进程发送 mach 消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里计算所需分配空间的大小</span></div><div class="line"><span class="keyword">vm_size_t</span> size(depth + Stack_);</div><div class="line"><span class="comment">// 向目标进程发出请求，获取它的 mach task</span></div><div class="line"><span class="keyword">mach_port_t</span> self(mach_task_self()), task;</div><div class="line">_krncall(task_for_pid(self, pid, &amp;task));</div><div class="line"><span class="comment">// 然后在目标进程中分配 size 大小的空间，起始地址在 stack 中</span></div><div class="line"><span class="keyword">vm_address_t</span> <span class="built_in">stack</span>;</div><div class="line">_krncall(vm_allocate(task, &amp;<span class="built_in">stack</span>, size, <span class="literal">true</span>));</div><div class="line"><span class="comment">// 计算 Baton 存放的地址</span></div><div class="line"><span class="keyword">vm_address_t</span> data(<span class="built_in">stack</span> + Stack_);</div><div class="line"><span class="comment">// 将 baton 写入宿主进程空间中</span></div><div class="line">_krncall(vm_write(task, data, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">vm_address_t</span>&gt;(baton), depth));</div></pre></td></tr></table></figure>
<p>这个时候已经将要加载的动态库信息放入了宿主空间中，然后就是让宿主去加载动态库了。这一切的实现都依赖于 mach 的进程远程调用，让这些实现成为可能。</p>
<p>因为程序的主线程正在执行它自己的工作，无法引导，所以这里就创建了一个新的线程，让注入的代码能跑起来，代码比较长，说明都在注释中了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里通过 mach 调用在宿主进程创建了一个新的线程对象</span></div><div class="line"><span class="keyword">thread_act_t</span> thread;</div><div class="line">_krncall(thread_create(task, &amp;thread));</div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">XXX:</span> look into using thread_get_state(THREAD_STATE_FLAVOR_LIST) to look up flavor</span></div><div class="line"><span class="comment">// 这里对线程做了一些配置</span></div><div class="line"><span class="keyword">thread_state_flavor_t</span> flavor;</div><div class="line"><span class="keyword">mach_msg_type_number_t</span> count;</div><div class="line"><span class="keyword">size_t</span> push;</div><div class="line"><span class="comment">// 这就是我们的蹦床对象</span></div><div class="line">Trampoline *trampoline;</div><div class="line"><span class="comment">// 我们只看 arm 的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)</span></div><div class="line">trampoline = &amp;Trampoline_armv6_; <span class="comment">// 这里明显是一个常量，但是在程序中找不到符号</span></div><div class="line"><span class="keyword">arm_thread_state_t</span> state;</div><div class="line">flavor = ARM_THREAD_STATE;</div><div class="line">count = ARM_THREAD_STATE_COUNT;</div><div class="line">push = <span class="number">0</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></div><div class="line"><span class="comment">// for i386</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__x86_64__)</span></div><div class="line"><span class="comment">// for x86_64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> XXX: implement</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="comment">// 这里利用了一样的方式，将蹦床注入到宿主进程空间中，这里面包含了可执行代码</span></div><div class="line"><span class="keyword">vm_address_t</span> code;</div><div class="line">_krncall(vm_allocate(task, &amp;code, trampoline-&gt;size_, <span class="literal">true</span>));</div><div class="line">_krncall(vm_write(task, code, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">vm_address_t</span>&gt;(trampoline-&gt;data_), trampoline-&gt;size_));</div><div class="line">_krncall(vm_protect(task, code, trampoline-&gt;size_, <span class="literal">false</span>, VM_PROT_READ | VM_PROT_EXECUTE));</div><div class="line"><span class="comment">// 在 arm 中 frame 的大小为 0</span></div><div class="line"><span class="keyword">uint32_t</span> frame[push];</div><div class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span>(frame) != <span class="number">0</span>)</div><div class="line">    <span class="built_in">memset</span>(frame, <span class="number">0</span>, <span class="keyword">sizeof</span>(frame));</div><div class="line"><span class="built_in">memset</span>(&amp;state, <span class="number">0</span>, <span class="keyword">sizeof</span>(state));</div><div class="line"><span class="comment">// 这里获取线程的状态信息</span></div><div class="line"><span class="keyword">mach_msg_type_number_t</span> read(count);</div><div class="line">_krncall(thread_get_state(thread, flavor, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">thread_state_t</span>&gt;(&amp;state), &amp;read));</div><div class="line"></div><div class="line"><span class="keyword">if</span> (read != count) &#123;</div><div class="line">    MSLog(MSLogLevelError, <span class="string">"MSError: thread_get_state(%d) == %d"</span>, count, read);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// this code is very similar to that found in Libc/pthread's _pthread_setup</span></div><div class="line"><span class="comment">// 这里的函数我们只看 arm 的</span></div><div class="line"><span class="comment">// 这里设置了新线程的 数据段、堆栈段、以及将 pc 设置到蹦床的入口，</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)</span></div><div class="line">state.__r[<span class="number">0</span>] = data;</div><div class="line">state.__sp = <span class="built_in">stack</span> + Stack_;</div><div class="line">state.__pc = code + trampoline-&gt;entry_;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// ARM has two execution states: ARM (32-bit) and Thumb (16/32-bit), using different instruction sets</span></div><div class="line"><span class="comment">// for addressing, we tell using the least significant bit: off-aligned addresses are assumed to be Thumb</span></div><div class="line"><span class="comment">// however, despite the CPU interpreting this bit during branches, it stores this information in CPSR</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ((state.__pc &amp; <span class="number">0x1</span>) != <span class="number">0</span>) &#123;</div><div class="line">    state.__pc &amp;= ~<span class="number">0x1</span>;</div><div class="line">    state.__cpsr |= <span class="number">0x20</span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></div><div class="line"><span class="comment">// for i386</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__x86_64__)</span></div><div class="line"><span class="comment">// for x86_64</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">error</span> XXX: implement</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">// 在 arm 下这个为 0</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">sizeof</span>(frame) != <span class="number">0</span>)</div><div class="line">    _krncall(vm_write(task, <span class="built_in">stack</span> + Stack_ - <span class="keyword">sizeof</span>(frame), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">vm_address_t</span>&gt;(frame), <span class="keyword">sizeof</span>(frame)));</div><div class="line"><span class="comment">// 设置线程状态并且启动</span></div><div class="line">_krncall(thread_set_state(thread, flavor, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">thread_state_t</span>&gt;(&amp;state), count));</div><div class="line">_krncall(thread_resume(thread));</div></pre></td></tr></table></figure>
<p>至此主要流程就已经结束了，剩下的则是监听这个线程是否是否消亡，保证程序执行完毕并且正确回收资源。</p>
<p>这个代码中依旧留下了一个疑点，即 <code>Trampoline</code>，这个跳板被注入到了程序中被执行，它做了什么？</p>
<h3 id="跳板程序-trampoline"><a class="markdownIt-Anchor" href="#跳板程序-trampoline"></a> 跳板程序 Trampoline</h3>
<p>之前的代码留下了一个 <code>Trampoline_armv6_</code> 常量对象，而且关于这个跳板程序的文件有一下几个：</p>
<ul>
<li>Trampoline.hpp</li>
<li><a href="http://trampoline.sh" target="_blank" rel="external">trampoline.sh</a></li>
<li>Trampoline.t.cpp</li>
</ul>
<p>头文件的内容很少，只定义了如下数据结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trampoline</span> &#123;</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *data_;</div><div class="line">    <span class="keyword">size_t</span> size_;</div><div class="line">    <span class="keyword">size_t</span> entry_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>包装了代码的数据以及大小、入口位置。</p>
<p>在 Trampoline.t.cpp 中的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">(Baton *baton)</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// 处理初始化 self</span></div><div class="line">    </div><div class="line">    baton-&gt;__pthread_set_self(&amp;self);</div><div class="line"></div><div class="line">    <span class="comment">//... 处理 self 在 arm 上的问题</span></div><div class="line"></div><div class="line">    <span class="comment">// 核心 创建了一个线程执行 Routine 函数</span></div><div class="line">    <span class="keyword">pthread_t</span> thread;</div><div class="line">    baton-&gt;pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;Routine, baton);</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *status;</div><div class="line">    baton-&gt;pthread_join(thread, &amp;status);</div><div class="line"></div><div class="line">    baton-&gt;thread_terminate(port);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>线程执行的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Routine</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</div><div class="line">    Baton *baton(reinterpret_cast&lt;Baton *&gt;(arg));</div><div class="line"></div><div class="line">    <span class="keyword">void</span> *(*dlopen)(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>);</div><div class="line">    dlset(baton, dlopen, <span class="string">"dlopen"</span>);</div><div class="line">    <span class="comment">// 这里执行的程序就是在宿主进程中加载我们要注入的动态库</span></div><div class="line">    void *handle(dlopen(baton-&gt;library, RTLD_LAZY | RTLD_LOCAL));</div><div class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</div><div class="line">        baton-&gt;dlerror();</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> (*dlclose)(<span class="keyword">void</span> *);</div><div class="line">    dlset(baton, dlclose, <span class="string">"dlclose"</span>);</div><div class="line"></div><div class="line">    dlclose(handle);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些工作都是在宿主的进程空间中执行的，所以加载的动态库也属于宿主空间了。</p>
<p>至于 <code>Trampoline_armv6_</code> 的生成，查看编译脚本有如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="section">%.t.hpp: %.t.cpp trampoline.sh</span></div><div class="line">	./trampoline.sh <span class="variable">$@</span> <span class="variable">$*</span>.dylib <span class="variable">$*</span> sed otool lipo nm ./cycc <span class="variable">$(ios)</span> <span class="variable">$(mac)</span> -o<span class="variable">$*</span>.dylib -- -dynamiclib <span class="variable">$&lt;</span> -Iinclude -Xarch_armv6 -marm</div></pre></td></tr></table></figure>
<p>这个脚本的动作则是将 <code>Trampoline.t.cpp</code> 在不同的平台上编译好后，利用 lipo 查看目标文件的架构，对于每一个架构，利用 otool + sed + nm 分析 <code>_Start</code> 的入口点以及可执行段的位置和大小，生成对应的常量对象写到 <code>Trampoline.t.hpp</code> 中。所以可以看到，DarwinInjector.cpp 中有 <code>#include &quot;Trampoline.t.hpp&quot;</code>。</p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>所以，整个注入流程则是：</p>
<blockquote>
<p>注入跳板 -&gt; 远程创建线程执行跳板 -&gt; 跳板开线程加载动态库</p>
</blockquote>
<p>至此，进程注入的部分就分析的差不多了，可以看到 Mach 对程序的进程间远程调用的力量是如此强大让许多黑科技得到了实现。</p>
<h2 id="mshookfunction"><a class="markdownIt-Anchor" href="#mshookfunction"></a> MSHookFunction</h2>
<p>这个函数实现了对 C/C++ 函数的 hook。也是 CydiaSubstrate 提供的基础功能之一。</p>
<p>同样这里也先放出其思路，其实也很简单：</p>
<blockquote>
<p>修改函数的入口，先跳转到代替函数，对原来的函数入口做一个备份返回</p>
</blockquote>
<h3 id="函数原型"><a class="markdownIt-Anchor" href="#函数原型"></a> 函数原型</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">MSHookFunction</span><span class="params">(<span class="keyword">void</span> *symbol, <span class="keyword">void</span> *replace, <span class="keyword">void</span> **result)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> SubstrateHookFunction(<span class="literal">NULL</span>, symbol, replace, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上面的代码可以看出 <code>MSHookFunction</code> 其实是对 <code>SubstrateHookFunction</code> 的包装，后者根据不同的平台有不同的实现，因为代码是跑在手机上的，所以下面只摘取了 arm 部分的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SubstrateHookFunction</span><span class="params">(SubstrateProcessRef process, <span class="keyword">void</span> *symbol, <span class="keyword">void</span> *replace, <span class="keyword">void</span> **result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (MSDebug)</div><div class="line">        MSLog(MSLogLevelNotice, <span class="string">"SubstrateHookFunction(%p, %p, %p, %p)"</span>, process, symbol, replace, result);</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(symbol) &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> SubstrateHookFunctionARM(process, symbol, replace, result);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> SubstrateHookFunctionThumb(process, <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(symbol) &amp; ~<span class="number">0x1</span>), replace, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 ARM 指令有两种形式：ARM 指令和 Thumb 指令，对于不同的指令执行方式，Cyida使用了不同的 hook 方式。这里拿 ARM 指令方式的函数，即 SubstrateHookFunctionARM 来做分析。</p>
<h3 id="arm-指令注入"><a class="markdownIt-Anchor" href="#arm-指令注入"></a> ARM 指令注入</h3>
<p>函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SubstrateHookFunctionARM</span><span class="params">(SubstrateProcessRef process, <span class="keyword">void</span> *symbol, <span class="keyword">void</span> *replace, <span class="keyword">void</span> **result)</span></span></div></pre></td></tr></table></figure>
<p>包装调用是 process 为 NULL，内部代码中也没有使用到，symbol 则是要被 hook 的函数地址，replace 则是用于替代原函数的函数，result 则是被处理过的原函数的备份地址。具体为何如此设计，待我们分析慢慢道来。</p>
<h3 id="备份指令"><a class="markdownIt-Anchor" href="#备份指令"></a> 备份指令</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (symbol == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="keyword">uint32_t</span> *area(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(symbol));</div><div class="line"><span class="keyword">uint32_t</span> *arm(area);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">const</span> size_t <span class="title">used</span><span class="params">(<span class="number">8</span>)</span></span>; <span class="comment">// 单位是byte，要替换的是函数的前两个指令</span></div><div class="line"><span class="comment">// 读取前两条指令作为备份</span></div><div class="line"><span class="keyword">uint32_t</span> backup[used / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)] = &#123;arm[<span class="number">0</span>], arm[<span class="number">1</span>]&#125;;</div></pre></td></tr></table></figure>
<p>上面的函数获取了原函数的地址，并且取出了前两条 ARM 指令做为备份。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> length(used);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> offset(<span class="number">0</span>); offset != used / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); ++offset)</div><div class="line">    <span class="keyword">if</span> (A$pcrel$r(backup[offset])) &#123; <span class="comment">// 下面解释</span></div><div class="line">        <span class="keyword">if</span> ((backup[offset] &amp; <span class="number">0x02000000</span>) == <span class="number">0</span> || (backup[offset] &amp; <span class="number">0x0000f000</span> &gt;&gt; <span class="number">12</span>) != (backup[offset] &amp; <span class="number">0x0000000f</span>)) <span class="comment">// 下面解释</span></div><div class="line">            length += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); <span class="comment">// 加两个指令长度</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            length += <span class="number">4</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); <span class="comment">// 加四个指令长度</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">length += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); <span class="comment">// 再加两个指令长度</span></div></pre></td></tr></table></figure>
<p>这里是在计算替换掉的两条指令需要用多少指令来进行还原。这个 for 循环其实值执行了两次，也就是查看了一下被替换的两条指令的情况。</p>
<p>核心检查在 <code>A$pcrel$r(backup[offset])</code> 函数，这个函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> A$pcrel$r(<span class="keyword">uint32_t</span> ic) &#123; </div><div class="line">    <span class="keyword">return</span> (ic &amp; <span class="number">0x0c000000</span>) == <span class="number">0x04000000</span> &amp;&amp; (ic &amp; <span class="number">0xf0000000</span>) != <span class="number">0xf0000000</span> &amp;&amp; (ic &amp; <span class="number">0x000f0000</span>) == <span class="number">0x000f0000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到这估计就会慌了，这究竟是个啥？这奇怪的函数名究竟是个啥？</p>
<p>这里就需要查询一下 ARM 的指令手册了，因为观察了一下调用是传进来的参数，是一条 ARM 机器指令，说明这里就是一个机器指令的检查。</p>
<p><strong>ARM 指令格式</strong></p>
<p>ARM 指令都是定长的，所有指令都是 32 位，占 4 个字节的空间。下面的表展示了 ARM 指令各个为代表的内容：</p>
<img src="/Cydia-的-Hook-原理/15441006537689.jpg">
<p>现在回顾函数的做的三个判断条件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   (ic &amp; <span class="number">0x0c000000</span>) == <span class="number">0x04000000</span></div><div class="line">&amp;&amp; (ic &amp; <span class="number">0xf0000000</span>) != <span class="number">0xf0000000</span> </div><div class="line">&amp;&amp; (ic &amp; <span class="number">0x000f0000</span>) == <span class="number">0x000f0000</span></div></pre></td></tr></table></figure>
<p>这些都是取出了某些位然后做出的检查判断。</p>
<p>第一个取出了指令的第 26~27 号位，这几位表示了指令的类型，检查这几位是否是 <code>01</code>。说明第一个是在检查指令是否是内存的读写指令。<br>
第二个取出了指令的第 28~31 号位，并且希望它不是全 1，看到是不希望指令为无条件的指令。<br>
第三个取出了指令的第 16~19 号位，即 <code>Rn</code>，表示源操作数，并且希望它为 <code>0b1111</code>，即寄存器 <code>pc</code>。</p>
<p>综合起来似乎就是判断这个指令是否是依赖 pc 来定位读写地址的指令。<br>
回顾其函数名 <code>A$pcrel$r</code> <strong>A</strong> 就代表 ARM，中间的 <strong>pcrel</strong> 似乎就表着 pc relative。</p>
<p>但是为什么要做这种检查还不能太早下定论，需要进一步的探索才能了解。（当然，根据实现思路应该可以猜到是为什么了）</p>
<p>然后这个函数检查生效以后还有一个判断条件走不同的分支：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">   (backup[offset] &amp; <span class="number">0x02000000</span>) == <span class="number">0</span>  </div><div class="line">|| (backup[offset] &amp; <span class="number">0x0000f000</span> &gt;&gt; <span class="number">12</span>) != (backup[offset] &amp; <span class="number">0x0000000f</span>)</div></pre></td></tr></table></figure>
<p>用和上面相同的办法进行查找，不过，因为第一个判断已经确定一个读写指令，所以可以对照读写指令的详细格式：</p>
<img src="/Cydia-的-Hook-原理/15441020057624.jpg">
<img src="/Cydia-的-Hook-原理/15441547925906.jpg">
<ul>
<li>I 指示指令的寻址方式，0 为立即数寻址，1 为寄存器寻址</li>
</ul>
<p>第一个条件取出了指令的第 25 号位，判断是否为 0<br>
第二个条件取出了指令的第 12~15 号位，并向右移 12 为，与第 0~4 号位进行比较，即比较Rd 与 Rm 是否相同。</p>
<p>这个条件则在筛选相对 pc 立即数寻址，即 <code>ldr rd, [pc, #im]</code> 这类指令以及 <code>ldr rd, [pc, rd]</code> 这类指令。</p>
<p>这类指令只需要 2 个多余指令来做还原处理，其他的则需要 4 个指令处理。</p>
<h3 id="填充指令"><a class="markdownIt-Anchor" href="#填充指令"></a> 填充指令</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> *buffer(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(mmap(</div><div class="line">    <span class="literal">NULL</span>, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span></div><div class="line">)));</div></pre></td></tr></table></figure>
<p>分配一块内存，存放新的执行代码。<br>
接下来开始填充代码，源代码如下：（不要紧张，可以先简单阅读，找出一些关键点）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> start(<span class="number">0</span>), end(length / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)); <span class="comment">// 单位是指令数</span></div><div class="line"><span class="keyword">uint32_t</span> *trailer(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(buffer + end)); <span class="comment">// 这里指向了最后一条指令 + 1</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> offset(<span class="number">0</span>); offset != used / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>); ++offset) </div><div class="line">        <span class="comment">// 这里的检查与上面计算指令数的条件是一样的</span></div><div class="line">    <span class="keyword">if</span> (A$pcrel$r(backup[offset])) &#123; </div><div class="line">        <span class="keyword">union</span> &#123;</div><div class="line">            <span class="keyword">uint32_t</span> value;</div><div class="line">            <span class="comment">// 这里讲指令进行了分解，可以看到分解的情况跟之前的图是对应的</span></div><div class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">                <span class="keyword">uint32_t</span> rm : <span class="number">4</span>;</div><div class="line">                <span class="keyword">uint32_t</span> : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> shift : <span class="number">2</span>;</div><div class="line">                <span class="keyword">uint32_t</span> shiftamount : <span class="number">5</span>;</div><div class="line">                <span class="keyword">uint32_t</span> rd : <span class="number">4</span>;</div><div class="line">                <span class="keyword">uint32_t</span> rn : <span class="number">4</span>;</div><div class="line">                <span class="keyword">uint32_t</span> l : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> w : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> b : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> u : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> p : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> mode : <span class="number">1</span>;</div><div class="line">                <span class="keyword">uint32_t</span> type : <span class="number">2</span>;</div><div class="line">                <span class="keyword">uint32_t</span> cond : <span class="number">4</span>;</div><div class="line">            &#125;;</div><div class="line">        &#125; bits = &#123;backup[offset+<span class="number">0</span>]&#125;, copy(bits); <span class="comment">// 这里对原来的指令做了一次拷贝</span></div><div class="line"></div><div class="line">        <span class="keyword">bool</span> guard;</div><div class="line">          <span class="comment">// 这个地方印证了在计算指令条数时，分析判断条件的正确性</span></div><div class="line">        <span class="comment">// 这里对原来的指令做出调整</span></div><div class="line">        <span class="keyword">if</span> (bits.mode == <span class="number">0</span> || bits.rd != bits.rm) &#123;</div><div class="line">            copy.rn = bits.rd;</div><div class="line">            guard = <span class="literal">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;</div><div class="line">            guard = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 将 copy.rn 内容压栈</span></div><div class="line">        <span class="keyword">if</span> (guard)</div><div class="line">            buffer[start++] = A$stmdb_sp$_$rs$((<span class="number">1</span> &lt;&lt; copy.rn));</div><div class="line">        <span class="comment">// 核心的调整代码</span></div><div class="line">        buffer[start+<span class="number">0</span>] = A$ldr_rd_$rn_im$(copy.rn, A$pc, (end<span class="number">-1</span> - (start+<span class="number">0</span>)) * <span class="number">4</span> - <span class="number">8</span>);</div><div class="line">        buffer[start+<span class="number">1</span>] = copy.value;</div><div class="line"></div><div class="line">        start += <span class="number">2</span>;</div><div class="line">        <span class="comment">// 将 copy.rn 从栈中读出来</span></div><div class="line">        <span class="keyword">if</span> (guard)</div><div class="line">            buffer[start++] = A$ldmia_sp$_$rs$((<span class="number">1</span> &lt;&lt; copy.rn));</div><div class="line">        <span class="comment">// 将原指令地址放在尾部</span></div><div class="line">        *--trailer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(area + offset) + <span class="number">8</span>;</div><div class="line">        end -= <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">        buffer[start++] = backup[offset]; <span class="comment">// 拷贝源指令</span></div><div class="line"><span class="comment">// 尾部的跳转指令</span></div><div class="line">buffer[start+<span class="number">0</span>] = A$ldr_rd_$rn_im$(A$pc, A$pc, <span class="number">4</span> - <span class="number">8</span>);</div><div class="line">buffer[start+<span class="number">1</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(area + used / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line"><span class="comment">// 给 buffer 执行的权限</span></div><div class="line"><span class="keyword">if</span> (mprotect(buffer, length, PROT_READ | PROT_EXEC) == <span class="number">-1</span>) &#123;</div><div class="line">    MSLog(MSLogLevelError, <span class="string">"MS:Error:mprotect():%d"</span>, errno);</div><div class="line">    <span class="keyword">goto</span> fail;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将修改好的源函数返回</span></div><div class="line">*result = buffer;</div><div class="line"><span class="comment">// 最后修改目标函数的代码</span></div><div class="line">&#123;</div><div class="line">    <span class="function">SubstrateHookMemory <span class="title">code</span><span class="params">(process, symbol, used)</span></span>;</div><div class="line"></div><div class="line">    arm[<span class="number">0</span>] = A$ldr_rd_$rn_im$(A$pc, A$pc, <span class="number">4</span> - <span class="number">8</span>);</div><div class="line">    arm[<span class="number">1</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(replace);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先忽略代码中指令调整的处理，从代码逻辑可以看出来，在最简单的情况下，这个程序对原程序作了如下图的调整：</p>
<img src="/Cydia-的-Hook-原理/15441532148701.jpg">
<p>通过修改 pc 的值，就可以实现直接的跳转，如此实现的调用原函数会跳转到替代函数中，而想要调用原函数时，只需要对 buffer 进行调用，让它来帮助跳转即可，所以计算长度时最后多家的两个指令就是为了处理跳转使用。</p>
<p>至此，按理说 Cyida 对 C 语言的 hook 原理已经很清楚了，但是为什么还多出了这么多处理呢？</p>
<h3 id="维护-pc-相对值"><a class="markdownIt-Anchor" href="#维护-pc-相对值"></a> 维护 pc 相对值</h3>
<p>设想一下，如果原指令1、2都是类似 <code>ldr rd, [pc, #im]</code> 的指令，即读取相对于 pc 值某个偏移量的地址下的值。上图中的最简单版本会造成错误的结果。因为 buffer 的地址与 origin 的地址并不相同，所以执行到相应指令时 pc 值是不正确的。</p>
<p>所以，解决办法是就这一类指令进行单独的处理，恢复修改后造成的错误。</p>
<h4 id="指令内容"><a class="markdownIt-Anchor" href="#指令内容"></a> 指令内容</h4>
<p>为了不影响继续阅读，先解析一下源代码中出现的指令情况。</p>
<p>对于 ARM 指令，源代码中定义了很多指令在 <code>ARM.happ</code> 中，源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ARM.hpp</span></div><div class="line"><span class="comment">// 代表 32位 ARM 汇编的所有寄存器</span></div><div class="line"><span class="keyword">enum</span> A$r &#123;</div><div class="line">    A$r0, A$r1, A$r2, A$r3,</div><div class="line">    A$r4, A$r5, A$r6, A$r7,</div><div class="line">    A$r8, A$r9, A$r10, A$r11,</div><div class="line">    A$r12, A$r13, A$r14, A$r15,</div><div class="line">    A$sp = A$r13,</div><div class="line">    A$lr = A$r14,</div><div class="line">    A$pc = A$r15</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 代表 ARM 汇编中所有的 cond 字段</span></div><div class="line"><span class="keyword">enum</span> A$c &#123;</div><div class="line">    A$eq, A$ne, A$cs, A$cc,</div><div class="line">    A$mi, A$pl, A$vs, A$vc,</div><div class="line">    A$hi, A$ls, A$ge, A$lt,</div><div class="line">    A$gt, A$le, A$al,</div><div class="line">    A$hs = A$cs,</div><div class="line">    A$lo = A$cc</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 一些列构造指令的宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$mrs_rm_cpsr(rd) <span class="comment">/* mrs rd, cpsr */</span> \</span></div><div class="line">    (<span class="number">0xe10f0000</span> | ((rd) &lt;&lt; <span class="number">12</span>))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$msr_cpsr_f_rm(rm) <span class="comment">/* msr cpsr_f, rm */</span> \</span></div><div class="line">    (<span class="number">0xe128f000</span> | (rm))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$ldr_rd_$rn_im$(rd, rn, im) <span class="comment">/* ldr rd, [rn, #im] */</span> \</span></div><div class="line">    (<span class="number">0xe5100000</span> | ((im) &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; <span class="number">23</span>) | ((rn) &lt;&lt; <span class="number">16</span>) | ((rd) &lt;&lt; <span class="number">12</span>) | <span class="built_in">abs</span>(im))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$str_rd_$rn_im$(rd, rn, im) <span class="comment">/* sr rd, [rn, #im] */</span> \</span></div><div class="line">    (<span class="number">0xe5000000</span> | ((im) &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; <span class="number">23</span>) | ((rn) &lt;&lt; <span class="number">16</span>) | ((rd) &lt;&lt; <span class="number">12</span>) | <span class="built_in">abs</span>(im))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$sub_rd_rn_$im(rd, rn, im) <span class="comment">/* sub, rd, rn, #im */</span> \</span></div><div class="line">    (<span class="number">0xe2400000</span> | ((rn) &lt;&lt; <span class="number">16</span>) | ((rd) &lt;&lt; <span class="number">12</span>) | (im &amp; <span class="number">0xff</span>))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$blx_rm(rm) <span class="comment">/* blx rm */</span> \</span></div><div class="line">    (<span class="number">0xe12fff30</span> | (rm))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$mov_rd_rm(rd, rm) <span class="comment">/* mov rd, rm */</span> \</span></div><div class="line">    (<span class="number">0xe1a00000</span> | ((rd) &lt;&lt; <span class="number">12</span>) | (rm))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$ldmia_sp$_$rs$(rs) <span class="comment">/* ldmia sp!, &#123;rs&#125; */</span> \</span></div><div class="line">    (<span class="number">0xe8b00000</span> | (A$sp &lt;&lt; <span class="number">16</span>) | (rs))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$stmdb_sp$_$rs$(rs) <span class="comment">/* stmdb sp!, &#123;rs&#125; */</span> \</span></div><div class="line">    (<span class="number">0xe9200000</span> | (A$sp &lt;&lt; <span class="number">16</span>) | (rs))</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$stmia_sp$_$r0$  0xe8ad0001 <span class="comment">/* stmia sp!, &#123;r0&#125;   */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$bx_r0           0xe12fff10 <span class="comment">/* bx r0             */</span></span></div></pre></td></tr></table></figure>
<p>这个文件定义了 ARM 的所有寄存器 <code>r0~r15</code>，不过关键是在还定义了许多宏，这些宏都代表了一条 ARM 指令。</p>
<p>这里拿出一个宏进行分析，其他的宏构造指令的方式都是一样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> A$ldr_rd_$rn_im$(rd, rn, im) <span class="comment">/* ldr rd, [rn, #im] */</span> \</span></div><div class="line">    (<span class="number">0xe5100000</span> | ((im) &lt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span> &lt;&lt; <span class="number">23</span>) | ((rn) &lt;&lt; <span class="number">16</span>) | ((rd) &lt;&lt; <span class="number">12</span>) | <span class="built_in">abs</span>(im))</div></pre></td></tr></table></figure>
<img src="/Cydia-的-Hook-原理/15441020057624.jpg">
<img src="/Cydia-的-Hook-原理/15441547925906.jpg">
<p>对照就可分析了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0xe5100000 -&gt; 1110 010 1 0 0 0 1 0000 0000 000000000000</div></pre></td></tr></table></figure>
<p>判断 im 是否为负，为负则将 U 置为 0 表示要减掉，1 表示为加上。然后将 <code>rn</code> <code>rd</code> 移动到对应的位置，最后的部分放置立即数。</p>
<h4 id="回到之前的讨论"><a class="markdownIt-Anchor" href="#回到之前的讨论"></a> 回到之前的讨论</h4>
<p>源代码中做的指令检查就是为了筛选出这类指令，恢复的过程摘录如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> guard;</div><div class="line"><span class="keyword">if</span> (bits.mode == <span class="number">0</span> || bits.rd != bits.rm) &#123;</div><div class="line">    copy.rn = bits.rd;</div><div class="line">    guard = <span class="literal">false</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    copy.rn = bits.rm != A$r0 ? A$r0 : A$r1;</div><div class="line">    guard = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (guard)</div><div class="line">    buffer[start++] = A$stmdb_sp$_$rs$((<span class="number">1</span> &lt;&lt; copy.rn));</div><div class="line"></div><div class="line">buffer[start+<span class="number">0</span>] = A$ldr_rd_$rn_im$(copy.rn, A$pc, (end<span class="number">-1</span> - (start+<span class="number">0</span>)) * <span class="number">4</span> - <span class="number">8</span>);</div><div class="line">buffer[start+<span class="number">1</span>] = copy.value;</div><div class="line"></div><div class="line">start += <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span> (guard)</div><div class="line">    buffer[start++] = A$ldmia_sp$_$rs$((<span class="number">1</span> &lt;&lt; copy.rn));</div><div class="line">*--trailer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(area + offset) + <span class="number">8</span>;</div><div class="line">end -= <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>这里依旧需要分成三种情况来讨论</p>
<h4 id="指令为立即数偏移"><a class="markdownIt-Anchor" href="#指令为立即数偏移"></a> 指令为立即数偏移</h4>
<p>指令为立即数偏移的情况来看，例如为如下指令：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">pc</span>, <span class="number">#0x10</span>]</div></pre></td></tr></table></figure>
<p>经过上述的修改流程，可以知道 buffer 中的代码变成了如下形式：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">pc</span>, <span class="symbol">#X</span>] <span class="comment">; 这里 [pc, #X] 指向了buffer末尾，存储原指令的地址</span></div><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">r8</span>, <span class="number">#10</span>]</div></pre></td></tr></table></figure>
<p>假设只有第一行是需要特殊处理的，并且第一条形式跟现在讨论的相同，由上述推知 buffer 应该有 6 个指令长，操作过后buffer指令的形式如下：</p>
<img src="/Cydia-的-Hook-原理/15441661281597.jpg">
<p>这里需要说明一下为什么会有一个 -8 的操作。查询 ARM 的手册，有如下几句话：</p>
<blockquote>
<p>For an ARM instruction, the value read is the address of the instruction plus 8 bytes. Bits [1:0] of this value are always zero, because ARM instructions are always word-aligned</p>
</blockquote>
<p>写入的话就是正常操作。如此这般就恢复了原来应该 r8 写入的值。</p>
<p>注意最后的地址为 origin + 8 而不是 origin 是因为原来的指令中读出的 <code>pc</code> 值是加了 8 的，这里也需要进行恢复。</p>
<h4 id="指令为寄存器偏移并且-rd-与-rm-不相同"><a class="markdownIt-Anchor" href="#指令为寄存器偏移并且-rd-与-rm-不相同"></a> 指令为寄存器偏移并且 rd 与 rm 不相同</h4>
<p>这种情况生成的代码与上面的类似，依旧拿一个指令举例：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">pc</span>, <span class="built_in">r9</span>] <span class="comment">; r8 = *(pc+r9)</span></div></pre></td></tr></table></figure>
<p>在前提跟上一中情况相同的情况下，buffer 中的代码只是第二条指令变成了</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">r8</span>, <span class="built_in">r9</span>]</div></pre></td></tr></table></figure>
<h4 id="指令为寄存器偏移并且-rd-与-rm-相同"><a class="markdownIt-Anchor" href="#指令为寄存器偏移并且-rd-与-rm-相同"></a> 指令为寄存器偏移并且 rd 与 rm 相同</h4>
<p>依旧举一个例子：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ldr </span><span class="built_in">r8</span>, [<span class="built_in">pc</span>, <span class="built_in">r8</span>]</div></pre></td></tr></table></figure>
<p>前提依旧跟第一种情况一样，不过现在 buffer 的长度为 8 条指令。</p>
<img src="/Cydia-的-Hook-原理/15441669629199.jpg">
<p>原理也很简单，因为这里需要一个中间变量 r0，但是又不能破坏原来 r0 中的值，所以使用栈暂时将 r0 的值进行保存。</p>
<h3 id="只能-hook-一次"><a class="markdownIt-Anchor" href="#只能-hook-一次"></a> 只能 hook 一次</h3>
<p>源代码在开始不久就有一个这样的检查，是不是很眼熟？这就是 hook 后修改的内存指令。这里检查函数是否被 hook 过了，如果被 hook 过了，就将 hook 的原 replace 函数作为结果返回，方便我们队之前的 hook 函数进行 hook。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (backup[<span class="number">0</span>] == A$ldr_rd_$rn_im$(A$pc, A$pc, <span class="number">4</span> - <span class="number">8</span>)) &#123;</div><div class="line">    *result = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(backup[<span class="number">1</span>]);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<p>自此，<code>SubstrateHookFunctionARM</code> 函数就分析完毕了，其实还有一个 <code>SubstrateHookFunctionThumb</code> 函数，负责用来 hook Thmub 指令模式下的函数。</p>
<p>经过了这一系列的操作，调用顺序这变成了下面的形式：</p>
<img src="/Cydia-的-Hook-原理/15441679053396.jpg">
<p>看上去似乎循环了，但是 Result 的跳转是到原函数的第3条指令，所以不会发生死循环。</p>
<h2 id="mshookmessage"><a class="markdownIt-Anchor" href="#mshookmessage"></a> MSHookMessage</h2>
<p>在 arm 中，Cyida 提供了三个接口对 Objective-C 的方法进行 hook：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_<span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">MSHookMessageEx</span><span class="params">(Class _class, SEL sel, IMP imp, IMP *result)</span></span>;</div><div class="line">_<span class="function"><span class="keyword">extern</span> IMP <span class="title">MSHookMessage</span><span class="params">(Class _class, SEL sel, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *prefix)</span></span>;</div><div class="line">_extern <span class="keyword">void</span> _Z13MSHookMessageP10objc_classP13objc_selectorPFP11objc_objectS4_S2_zEPKc(Class _class, SEL sel, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *prefix);</div></pre></td></tr></table></figure>
<p>这三个函数都是对一个核心函数的包装，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MSHookMessageInternal</span><span class="params">(Class _class, SEL sel, IMP imp, IMP *result, <span class="keyword">const</span> <span class="keyword">char</span> *prefix)</span></span>;</div></pre></td></tr></table></figure>
<p>几个参数分别是 目标类、目标方法，用于替换的方法实现、原函数的实现、原函数的重命名的前缀。</p>
<p>有了之前分析的经验，接下来的工作就会顺利很多，深吸一口气，开始吧！</p>
<h3 id="hookinternal"><a class="markdownIt-Anchor" href="#hookinternal"></a> HookInternal</h3>
<p>首先代码先从继承链上拿到目标方法以及相关信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Method method(MSFindMethod(_class, sel));</div><div class="line"><span class="comment">// 获取方法的参数类型编码</span></div><div class="line">const char *type(method_getTypeEncoding(method));</div></pre></td></tr></table></figure>
<p>函数的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Method <span class="title">MSFindMethod</span><span class="params">(Class _class, SEL sel)</span> </span>&#123;</div><div class="line">    <span class="comment">// 查找继承链</span></div><div class="line">    <span class="keyword">for</span> (; _class != nil; _class = class_getSuperclass(_class)) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</div><div class="line">        Method *methods(class_copyMethodList(_class, &amp;size));</div><div class="line">        <span class="keyword">if</span> (methods == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        <span class="comment">// 遍历所有方法进行查找</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> j(<span class="number">0</span>); j != size; ++j) &#123;</div><div class="line">            <span class="function">Method <span class="title">method</span><span class="params">(methods[j])</span></span>;</div><div class="line">            <span class="keyword">if</span> (!sel_isEqual(method_getName(methods[j]), sel))</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="built_in">free</span>(methods);</div><div class="line">            <span class="keyword">return</span> method;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(methods);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来判断目标函数是不是继承过来的，这点可以先留着：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">direct</span><span class="params">(<span class="literal">false</span>)</span></span>;</div><div class="line"><span class="keyword">unsigned</span> count;</div><div class="line">Method *methods(class_copyMethodList(_class, &amp;count));</div><div class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i(<span class="number">0</span>); i != count; ++i)</div><div class="line">    <span class="keyword">if</span> (methods[i] == method) &#123;</div><div class="line">        direct = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"><span class="built_in">free</span>(methods);</div></pre></td></tr></table></figure>
<p>接下来根据 direct 的值有一个分支：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">IMP <span class="title">old</span><span class="params">(<span class="literal">NULL</span>)</span></span>;</div><div class="line"><span class="keyword">if</span> (!direct) &#123;</div><div class="line">    <span class="comment">// ... 这里省略很多代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="替换实现"><a class="markdownIt-Anchor" href="#替换实现"></a> 替换实现</h3>
<p>然后就是核心的操作了，下面的注释基于假设方法是直属的假设进行分析的，利用了 Objective-C 的 runtime 技术：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (old == <span class="literal">NULL</span>) <span class="comment">// 这里获取到本类的实现</span></div><div class="line">    old = method_getImplementation(method);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>) <span class="comment">// 将旧的实现返回</span></div><div class="line">    *result = old;</div><div class="line"><span class="comment">// 如果这里有替换的前缀，把前缀加到原方法名前</span></div><div class="line"><span class="comment">// 以新的名字将原来的实现作为新方法加入原类中</span></div><div class="line"><span class="keyword">if</span> (prefix != <span class="literal">NULL</span>) &#123; </div><div class="line">    const char *name(sel_getName(sel));</div><div class="line">    <span class="keyword">size_t</span> namelen(<span class="built_in">strlen</span>(name));</div><div class="line">    <span class="keyword">size_t</span> fixlen(<span class="built_in">strlen</span>(prefix));</div><div class="line"></div><div class="line">    char *newname(reinterpret_cast&lt;char *&gt;(alloca(fixlen + namelen + 1)));</div><div class="line">    <span class="built_in">memcpy</span>(newname, prefix, fixlen);</div><div class="line">    <span class="built_in">memcpy</span>(newname + fixlen, name, namelen + <span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!class_addMethod(_class, sel_registerName(newname), old, type))</div><div class="line">        MSLog(MSLogLevelError, <span class="string">"MS:Error: failed to rename [%s %s]"</span>, class_getName(_class), name);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里假设方法是直属的，则直接将原方法的实现变更为新的实现</span></div><div class="line"><span class="keyword">if</span> (direct)</div><div class="line">    method_setImplementation(method, imp);</div><div class="line"><span class="keyword">else</span></div><div class="line">    class_addMethod(_class, sel, imp, type);</div></pre></td></tr></table></figure>
<p>将旧的实现返回以及使用新的名字将原来的函数放回方便调用，这是最基本的处理思路。<br>
至此，主要的替换方式就已经明确，但是下面还将讨论一下细节。</p>
<h3 id="direct"><a class="markdownIt-Anchor" href="#direct"></a> !direct</h3>
<p>接下来就是摘取看 <code>!direct</code> 分支究竟做了什么。这个前提是目标方法是继承而来的.<br>
下面的代码只展示了 arm 部分的代码并且删除了一些 log 语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!direct) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)</span></div><div class="line">    <span class="comment">// 熟悉的写法，这里表示代码长度为 11 个指令</span></div><div class="line">    <span class="keyword">size_t</span> length(<span class="number">11</span> * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__x86_64__)</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// 分配内存</span></div><div class="line">    <span class="keyword">uint32_t</span> *buffer(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(mmap(</div><div class="line">        <span class="literal">NULL</span>, length, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span></div><div class="line">    )));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (buffer == MAP_FAILED)</div><div class="line">        MSLog(MSLogLevelError, <span class="string">"MS:Error:mmap() = %d"</span>, errno);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span>) fail:</div><div class="line">        munmap(buffer, length);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Class super(class_getSuperclass(_class));</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm__)</span></div><div class="line">        <span class="comment">// 熟悉而又陌生的味道</span></div><div class="line">        buffer[ <span class="number">0</span>] = A$stmdb_sp$_$rs$((<span class="number">1</span> &lt;&lt; A$r0) | (<span class="number">1</span> &lt;&lt; A$r1) | (<span class="number">1</span> &lt;&lt; A$r2) | (<span class="number">1</span> &lt;&lt; A$r3) | (<span class="number">1</span> &lt;&lt; A$lr));</div><div class="line">        buffer[ <span class="number">1</span>] = A$ldr_rd_$rn_im$(A$r0, A$pc, ( <span class="number">8</span> - <span class="number">1</span> - <span class="number">2</span>) * <span class="number">4</span>);</div><div class="line">        buffer[ <span class="number">2</span>] = A$ldr_rd_$rn_im$(A$r1, A$pc, ( <span class="number">9</span> - <span class="number">2</span> - <span class="number">2</span>) * <span class="number">4</span>);</div><div class="line">        buffer[ <span class="number">3</span>] = A$ldr_rd_$rn_im$(A$lr, A$pc, (<span class="number">10</span> - <span class="number">3</span> - <span class="number">2</span>) * <span class="number">4</span>);</div><div class="line">        buffer[ <span class="number">4</span>] = A$blx_rm(A$lr);</div><div class="line">        buffer[ <span class="number">5</span>] = A$str_rd_$rn_im$(A$r0, A$sp, <span class="number">-4</span>);</div><div class="line">        buffer[ <span class="number">6</span>] = A$ldmia_sp$_$rs$((<span class="number">1</span> &lt;&lt; A$r0) | (<span class="number">1</span> &lt;&lt; A$r1) | (<span class="number">1</span> &lt;&lt; A$r2) | (<span class="number">1</span> &lt;&lt; A$r3) | (<span class="number">1</span> &lt;&lt; A$lr));</div><div class="line">        buffer[ <span class="number">7</span>] = A$ldr_rd_$rn_im$(A$pc, A$sp, <span class="number">-4</span> - (<span class="number">5</span> * <span class="number">4</span>));</div><div class="line">        buffer[ <span class="number">8</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(super);</div><div class="line">        buffer[ <span class="number">9</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(sel);</div><div class="line">        buffer[<span class="number">10</span>] = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(&amp;class_getMethodImplementation);</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(__x86_64__)</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mprotect(buffer, length, PROT_READ | PROT_EXEC) == <span class="number">-1</span>) &#123;</div><div class="line">            MSLog(MSLogLevelError, <span class="string">"MS:Error:mprotect():%d"</span>, errno);</div><div class="line">            <span class="keyword">goto</span> fail;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        old = <span class="keyword">reinterpret_cast</span>&lt;IMP&gt;(buffer);</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>依旧对照根据之前的宏，可以将 buffer 中的内容翻译成如下的汇编代码：</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">stmdb </span> <span class="built_in">sp</span>! &#123;<span class="built_in">r0</span>~<span class="built_in">r3</span>, <span class="built_in">lr</span>&#125;          <span class="comment">; 将 r0~r3, lr 入栈 </span></div><div class="line"><span class="keyword">ldr </span>   <span class="built_in">r0</span>, [<span class="built_in">pc</span>, #(<span class="number">8</span>-<span class="number">1</span>)*<span class="number">4</span>-<span class="number">8</span>]     <span class="comment">; 第一个参数 super</span></div><div class="line"><span class="keyword">ldr </span>   <span class="built_in">r1</span>, [<span class="built_in">pc</span>, #(<span class="number">9</span>-<span class="number">2</span>)*<span class="number">4</span>-<span class="number">8</span>]     <span class="comment">; 第二个参数 sel</span></div><div class="line"><span class="keyword">ldr </span>   <span class="built_in">lr</span>, [<span class="built_in">pc</span>, #(<span class="number">10</span>-<span class="number">3</span>)*<span class="number">4</span>-<span class="number">8</span>]    <span class="comment">; 获取 class_getMethodImplementation 的地址</span></div><div class="line"><span class="keyword">blx </span>   <span class="built_in">lr</span>                       <span class="comment">; 跳转到 class_getMethodImplementation 执行</span></div><div class="line"><span class="keyword">str </span>   <span class="built_in">r0</span>, [<span class="built_in">sp</span>, #-<span class="number">0x4</span>]          <span class="comment">; 将结果存入 sp-4 中</span></div><div class="line"><span class="keyword">ldmia </span>  <span class="built_in">sp</span>!, &#123;<span class="built_in">r0</span>~<span class="built_in">r3</span>, <span class="built_in">lr</span>&#125;         <span class="comment">; 将 r0~r3, lr 出栈</span></div><div class="line"><span class="keyword">ldr </span>   <span class="built_in">pc</span>, [<span class="built_in">sp</span>, #-<span class="number">0x18</span>]         <span class="comment">; 设置 pc 为获取到的地址，因为出栈了 5 个寄存器，占了 0x14 个字节空间</span></div><div class="line"><span class="comment">; addr of super</span></div><div class="line"><span class="comment">; addr of sel</span></div><div class="line"><span class="comment">; addr of class_getMethodImplementation</span></div></pre></td></tr></table></figure>
<p>这段代码是获取函数的父类的旧实现，然后跳转执行。此时 old 的实现变成了 buffer 这段代码。</p>
<p>在非直属方法的情况下，最后给本类添加新的同名方法，原函数的调用则返回了处理过后的 buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (direct)</div><div class="line">    method_setImplementation(method, imp);</div><div class="line"><span class="keyword">else</span>    <span class="comment">// 现在走这一段，给同名方法添加新的实现，因为本类没有。</span></div><div class="line">    class_addMethod(_class, sel, imp, type);</div></pre></td></tr></table></figure>
<p>为什么要做这个处理，参考 <a href="http://www.cydiasubstrate.com/api/c/MSHookMessageEx/" target="_blank" rel="external">官方说明页面</a> 提到：</p>
<blockquote>
<p>However, while these APIs function quite well when there are only a small number of people making modifications, they fail to satisfy more complex use cases; in particular, there are ordering problems if multiple people attempt to hook the same message at different points in an inheritance hierarchy.</p>
<p>Finally, it is important that classes that are being instrumented are not “initialized” as they are being modified (which would both change the ordering of the target program, as well as make it impossible to hook the initialization sequence); over time, the way Objective-C runtime APIs implement this has changed.</p>
<p>Substrate solves all of these problems by providing a replacement API that takes all of these issues into account, always making certain that the classes are not initialized and that the right “next implementation” is used while walking back up an inheritance hierarchy.</p>
</blockquote>
<p>这么做的目的是为了让继承链上的函数能得到正确的 <strong>next implementation</strong> 。</p>
<p><strong>情景分析：</strong></p>
<p>考虑如下的继承关系 A 类，B 类，C 类，继承关系为 <code>C -&gt; B -&gt; A</code>，现在 A 类有一个方法 <code>method</code>，并且 B、C 类都没有实现，即从 A 类继承的方法。</p>
<p>所有 hook 后的替换函数都调用了原函数以保证功能正确。</p>
<p>假设 C 先 hook，B 后 hook。</p>
<p>如果没有如此上面的处理，直接将父类的实现地址放到内存中，则会产生如下的调用链：</p>
<img src="/Cydia-的-Hook-原理/15441760691225.jpg">
<p>因为 B 的 <code>method</code> 后与 C 添加，所以在调用 <code>[c method]</code> 时不会运行 B 的自定义函数。</p>
<p>如果做了上述的处理，就可以动态的查询父类的实现，就能生成如下如下的调用链：</p>
<img src="/Cydia-的-Hook-原理/15441763854689.jpg">
<p>这样在调用 <code>[c method]</code> 时，B 的函数也能正确的被调用。使得调用的顺序与 hook 的顺序无关。</p>
<h3 id="总结-3"><a class="markdownIt-Anchor" href="#总结-3"></a> 总结</h3>
<p>OC 的 runtime 机制让 OC 方法的 hook 实现简单了很多，利用方法实现的替换就可以做到对方法的 hook。这里的精髓则是在 hook 时，对调用链进行的处理。</p>
<h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2>
<p>Cydia 提供了三个接口来进行 hook 工作，但是开放的只有后两个。这里充分体现了对函数 hook 的思想：</p>
<blockquote>
<p>在程序入口做跳转，保存原来的函数地址。</p>
</blockquote>
<p>Cydia 的实现，大都是修改了对应函数的部分内存，利用 mach 的一些系统调用来注入自己的代码。对 ARM 代码直接编码进行注入的方式也是比较精巧的。让人受益匪浅。</p>
<p>可惜的是这是一个老版本的源码，都是建立在 32 位的 ARM 汇编下做的处理。因为高版本的 Cydia 已经闭源，所以只能通过逆向的方式对其 hook 原理做探索了。但是老基本的思想应该是不变的。</p>
<p>只能说，是真的大牛，学到了。</p>
<h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2>
<ul>
<li><a href="https://amywushu.github.io/2017/03/07/%E9%80%86%E5%90%91%E7%9F%A5%E8%AF%86-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-CydiaSubstrate%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AMSHookMessageEx.html" target="_blank" rel="external">Hook 原理之 CydiaSubstrate（一）：MSHookMessageEx</a></li>
<li>ARM Architecture Reference Manual</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/源码阅读/" rel="tag"># 源码阅读</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/CydiaSubstrate-引导过程/" rel="next" title="CydiaSubstrate 引导过程">
                <i class="fa fa-chevron-left"></i> CydiaSubstrate 引导过程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/CMake-小计/" rel="prev" title="CMake 小计">
                CMake 小计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTY4MS84MjQ1"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="BluesJiang" />
            
              <p class="site-author-name" itemprop="name">BluesJiang</p>
              <p class="site-description motion-element" itemprop="description">A little iOS new bee</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/bluesjiang" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#mshookprocess"><span class="nav-number">1.</span> <span class="nav-text"> MSHookProcess</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注入蹦床"><span class="nav-number">1.1.</span> <span class="nav-text"> 注入蹦床</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳板程序-trampoline"><span class="nav-number">1.2.</span> <span class="nav-text"> 跳板程序 Trampoline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.3.</span> <span class="nav-text"> 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mshookfunction"><span class="nav-number">2.</span> <span class="nav-text"> MSHookFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数原型"><span class="nav-number">2.1.</span> <span class="nav-text"> 函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arm-指令注入"><span class="nav-number">2.2.</span> <span class="nav-text"> ARM 指令注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#备份指令"><span class="nav-number">2.3.</span> <span class="nav-text"> 备份指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#填充指令"><span class="nav-number">2.4.</span> <span class="nav-text"> 填充指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#维护-pc-相对值"><span class="nav-number">2.5.</span> <span class="nav-text"> 维护 pc 相对值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指令内容"><span class="nav-number">2.5.1.</span> <span class="nav-text"> 指令内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回到之前的讨论"><span class="nav-number">2.5.2.</span> <span class="nav-text"> 回到之前的讨论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令为立即数偏移"><span class="nav-number">2.5.3.</span> <span class="nav-text"> 指令为立即数偏移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令为寄存器偏移并且-rd-与-rm-不相同"><span class="nav-number">2.5.4.</span> <span class="nav-text"> 指令为寄存器偏移并且 rd 与 rm 不相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#指令为寄存器偏移并且-rd-与-rm-相同"><span class="nav-number">2.5.5.</span> <span class="nav-text"> 指令为寄存器偏移并且 rd 与 rm 相同</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只能-hook-一次"><span class="nav-number">2.6.</span> <span class="nav-text"> 只能 hook 一次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">2.7.</span> <span class="nav-text"> 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mshookmessage"><span class="nav-number">3.</span> <span class="nav-text"> MSHookMessage</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hookinternal"><span class="nav-number">3.1.</span> <span class="nav-text"> HookInternal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#替换实现"><span class="nav-number">3.2.</span> <span class="nav-text"> 替换实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#direct"><span class="nav-number">3.3.</span> <span class="nav-text"> !direct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">3.4.</span> <span class="nav-text"> 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">4.</span> <span class="nav-text"> Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">5.</span> <span class="nav-text"> 参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BluesJiang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>





  <script src='https://unpkg.com/mermaid@<%= theme.mermaid.version %>/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

  

  

  

</body>
</html>
